import { test, expect } from '@playwright/test';
import { signInUser, TEST_USERS, getTestUserId, createTestNode } from './utils/auth';

test.describe('Embedding Generation Edge Functions', () => {
  test.beforeEach(async ({ page }) => {
    await signInUser(page, TEST_USERS.USER_1);
  });

  test('should generate embeddings for new nodes', async ({ page, request }) => {
    // Get auth token
    const authToken = await page.evaluate(() => {
      const auth = JSON.parse(localStorage.getItem('supabase.auth.token') || '{}');
      return auth.access_token;
    });

    // Create a node with text content that should generate embeddings
    const createResponse = await request.post(`${process.env.PLAYWRIGHT_BASE_URL || 'http://localhost:3000'}/api/graph-operations`, {
      headers: {
        'Authorization': `Bearer ${authToken}`,
        'Content-Type': 'application/json'
      },
      data: {
        operation: 'create_node',
        data: {
          node_type: 'goal',
          label: 'Learn Machine Learning',
          description: 'Master artificial intelligence and deep learning concepts to build intelligent systems',
          status: 'draft_verbal'
        }
      }
    });

    expect(createResponse.ok()).toBeTruthy();
    const nodeData = await createResponse.json();
    const nodeId = nodeData.data.id;

    // Wait for embeddings to be generated (this might take a few seconds)
    await page.waitForTimeout(5000);

    // Check if embeddings were generated by calling the embedding edge function
    const embeddingResponse = await request.post(
      `${process.env.NEXT_PUBLIC_SUPABASE_URL}/functions/v1/generate-embeddings`,
      {
        headers: {
          'Authorization': `Bearer ${authToken}`,
          'Content-Type': 'application/json'
        },
        data: {
          node_id: nodeId,
          text: 'Learn Machine Learning Master artificial intelligence and deep learning concepts to build intelligent systems'
        }
      }
    );

    expect(embeddingResponse.ok()).toBeTruthy();
    const embeddingResult = await embeddingResponse.json();
    expect(embeddingResult.success).toBeTruthy();
  });

  test('should handle embedding generation errors gracefully', async ({ page, request }) => {
    const authToken = await page.evaluate(() => {
      const auth = JSON.parse(localStorage.getItem('supabase.auth.token') || '{}');
      return auth.access_token;
    });

    // Try to generate embeddings with invalid data
    const invalidEmbeddingResponse = await request.post(
      `${process.env.NEXT_PUBLIC_SUPABASE_URL}/functions/v1/generate-embeddings`,
      {
        headers: {
          'Authorization': `Bearer ${authToken}`,
          'Content-Type': 'application/json'
        },
        data: {
          node_id: 'invalid-node-id',
          text: ''
        }
      }
    );

    // Should handle the error without crashing
    expect(invalidEmbeddingResponse.status).toBeGreaterThanOrEqual(400);
  });

  test('should update embeddings when node content changes', async ({ page, request }) => {
    // Create a node first
    const userId = await getTestUserId(TEST_USERS.USER_1.email);
    const testNode = await createTestNode(userId, {
      node_type: 'goal',
      label: 'Original Goal',
      description: 'Original description for embedding generation'
    });

    const authToken = await page.evaluate(() => {
      const auth = JSON.parse(localStorage.getItem('supabase.auth.token') || '{}');
      return auth.access_token;
    });

    // Generate initial embeddings
    const initialEmbeddingResponse = await request.post(
      `${process.env.NEXT_PUBLIC_SUPABASE_URL}/functions/v1/generate-embeddings`,
      {
        headers: {
          'Authorization': `Bearer ${authToken}`,
          'Content-Type': 'application/json'
        },
        data: {
          node_id: testNode.id,
          text: 'Original Goal Original description for embedding generation'
        }
      }
    );

    expect(initialEmbeddingResponse.ok()).toBeTruthy();

    // Update the node content
    const updateResponse = await request.post(`${process.env.PLAYWRIGHT_BASE_URL || 'http://localhost:3000'}/api/graph-operations`, {
      headers: {
        'Authorization': `Bearer ${authToken}`,
        'Content-Type': 'application/json'
      },
      data: {
        operation: 'update_node',
        data: {
          nodeId: testNode.id,
          updates: {
            label: 'Updated Goal Title',
            description: 'Completely different description with new semantic meaning for updated embeddings'
          }
        }
      }
    });

    expect(updateResponse.ok()).toBeTruthy();

    // Generate new embeddings for updated content
    const updatedEmbeddingResponse = await request.post(
      `${process.env.NEXT_PUBLIC_SUPABASE_URL}/functions/v1/generate-embeddings`,
      {
        headers: {
          'Authorization': `Bearer ${authToken}`,
          'Content-Type': 'application/json'
        },
        data: {
          node_id: testNode.id,
          text: 'Updated Goal Title Completely different description with new semantic meaning for updated embeddings'
        }
      }
    );

    expect(updatedEmbeddingResponse.ok()).toBeTruthy();
  });

  test('should handle batch embedding generation', async ({ page, request }) => {
    const userId = await getTestUserId(TEST_USERS.USER_1.email);
    
    // Create multiple nodes
    const nodesToEmbed = [];
    for (let i = 0; i < 3; i++) {
      const node = await createTestNode(userId, {
        node_type: 'goal',
        label: `Batch Goal ${i + 1}`,
        description: `Description for batch embedding generation test node ${i + 1}`
      });
      nodesToEmbed.push(node);
    }

    const authToken = await page.evaluate(() => {
      const auth = JSON.parse(localStorage.getItem('supabase.auth.token') || '{}');
      return auth.access_token;
    });

    // Generate embeddings for all nodes
    const embeddingPromises = nodesToEmbed.map(node => 
      request.post(
        `${process.env.NEXT_PUBLIC_SUPABASE_URL}/functions/v1/generate-embeddings`,
        {
          headers: {
            'Authorization': `Bearer ${authToken}`,
            'Content-Type': 'application/json'
          },
          data: {
            node_id: node.id,
            text: `${node.label} ${node.description}`
          }
        }
      )
    );

    const embeddingResponses = await Promise.all(embeddingPromises);

    // All embedding generations should succeed
    for (const response of embeddingResponses) {
      expect(response.ok()).toBeTruthy();
    }
  });

  test('should use embeddings for similarity search', async ({ page, request }) => {
    // Create nodes with similar and different content
    const userId = await getTestUserId(TEST_USERS.USER_1.email);
    
    const similarNode1 = await createTestNode(userId, {
      node_type: 'goal',
      label: 'Learn Python Programming',
      description: 'Master Python programming language for data science and web development'
    });

    const similarNode2 = await createTestNode(userId, {
      node_type: 'goal', 
      label: 'Study JavaScript Development',
      description: 'Learn JavaScript programming for frontend and backend web development'
    });

    const differentNode = await createTestNode(userId, {
      node_type: 'goal',
      label: 'Practice Yoga',
      description: 'Improve flexibility and mindfulness through daily yoga practice'
    });

    const authToken = await page.evaluate(() => {
      const auth = JSON.parse(localStorage.getItem('supabase.auth.token') || '{}');
      return auth.access_token;
    });

    // Generate embeddings for all nodes
    const nodes = [similarNode1, similarNode2, differentNode];
    for (const node of nodes) {
      const embeddingResponse = await request.post(
        `${process.env.NEXT_PUBLIC_SUPABASE_URL}/functions/v1/generate-embeddings`,
        {
          headers: {
            'Authorization': `Bearer ${authToken}`,
            'Content-Type': 'application/json'
          },
          data: {
            node_id: node.id,
            text: `${node.label} ${node.description}`
          }
        }
      );
      expect(embeddingResponse.ok()).toBeTruthy();
    }

    // Wait for embeddings to be processed
    await page.waitForTimeout(3000);

    // Test knowledge search with programming-related query
    const searchResponse = await request.post(`${process.env.PLAYWRIGHT_BASE_URL || 'http://localhost:3000'}/api/knowledge/search`, {
      headers: {
        'Authorization': `Bearer ${authToken}`,
        'Content-Type': 'application/json'
      },
      data: {
        query: 'programming languages development',
        limit: 5
      }
    });

    if (searchResponse.ok()) {
      const searchResults = await searchResponse.json();
      
      // Programming-related nodes should have higher similarity scores
      const programmingResults = searchResults.results?.filter((result: any) => 
        result.content?.includes('Python') || result.content?.includes('JavaScript')
      );
      
      expect(programmingResults?.length).toBeGreaterThan(0);
    }
  });

  test('should handle embedding generation timeout', async ({ page, request }) => {
    const authToken = await page.evaluate(() => {
      const auth = JSON.parse(localStorage.getItem('supabase.auth.token') || '{}');
      return auth.access_token;
    });

    // Create a very long text that might cause timeout issues
    const longText = 'word '.repeat(10000); // Very long text
    
    const userId = await getTestUserId(TEST_USERS.USER_1.email);
    const testNode = await createTestNode(userId, {
      node_type: 'goal',
      label: 'Long Content Goal',
      description: longText
    });

    // Try to generate embeddings with very long content
    const embeddingResponse = await request.post(
      `${process.env.NEXT_PUBLIC_SUPABASE_URL}/functions/v1/generate-embeddings`,
      {
        headers: {
          'Authorization': `Bearer ${authToken}`,
          'Content-Type': 'application/json'
        },
        data: {
          node_id: testNode.id,
          text: longText
        },
        timeout: 30000 // 30 second timeout
      }
    );

    // Should either succeed or fail gracefully
    if (embeddingResponse.ok()) {
      const result = await embeddingResponse.json();
      expect(result.success).toBeTruthy();
    } else {
      // Should return appropriate error status
      expect(embeddingResponse.status).toBeGreaterThanOrEqual(400);
    }
  });

  test('should validate embedding vector dimensions', async ({ page, request }) => {
    const userId = await getTestUserId(TEST_USERS.USER_1.email);
    const testNode = await createTestNode(userId, {
      node_type: 'goal',
      label: 'Dimension Test Goal',
      description: 'Testing embedding vector dimensions and structure'
    });

    const authToken = await page.evaluate(() => {
      const auth = JSON.parse(localStorage.getItem('supabase.auth.token') || '{}');
      return auth.access_token;
    });

    const embeddingResponse = await request.post(
      `${process.env.NEXT_PUBLIC_SUPABASE_URL}/functions/v1/generate-embeddings`,
      {
        headers: {
          'Authorization': `Bearer ${authToken}`,
          'Content-Type': 'application/json'
        },
        data: {
          node_id: testNode.id,
          text: 'Dimension Test Goal Testing embedding vector dimensions and structure'
        }
      }
    );

    if (embeddingResponse.ok()) {
      const result = await embeddingResponse.json();
      
      // Verify embedding structure (depends on your implementation)
      if (result.embedding) {
        expect(Array.isArray(result.embedding)).toBeTruthy();
        expect(result.embedding.length).toBeGreaterThan(0);
        
        // OpenAI text-embedding-3-small typically has 1536 dimensions
        expect(result.embedding.length).toBe(1536);
        
        // All values should be numbers
        expect(result.embedding.every((val: any) => typeof val === 'number')).toBeTruthy();
      }
    }
  });

  test('should handle embedding queue processing', async ({ page, request }) => {
    const authToken = await page.evaluate(() => {
      const auth = JSON.parse(localStorage.getItem('supabase.auth.token') || '{}');
      return auth.access_token;
    });

    // Test the embedding queue processing function
    const queueResponse = await request.post(
      `${process.env.NEXT_PUBLIC_SUPABASE_URL}/functions/v1/process-embedding-queue`,
      {
        headers: {
          'Authorization': `Bearer ${authToken}`,
          'Content-Type': 'application/json'
        },
        data: {}
      }
    );

    // Should either process queue items or return that queue is empty
    if (queueResponse.ok()) {
      const result = await queueResponse.json();
      expect(result.processed).toBeDefined();
    } else {
      // Queue processing might not be available or might require admin permissions
      console.log('Queue processing not available or requires different permissions');
    }
  });
});